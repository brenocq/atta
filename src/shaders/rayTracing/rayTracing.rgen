//--------------------------------------------------
// Atta Ray Tracing Vulkan GLSL
// rayTracing.rgen
// Date: 2021-02-09
// By Breno Cunha Queiroz
//--------------------------------------------------
#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_tracing : require

#include "base.glsl"
#include "rayPayload.glsl"
#include "uniformBufferObject.glsl"
#include "../light.glsl"
#include "samplers/random.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureEXT scene;
layout(binding = 1, rgba32f) uniform image2D accumulationImage;
layout(binding = 2, rgba8) uniform image2D outputImage;
layout(binding = 3) readonly uniform UniformBufferObjectStruct { UniformBufferObject ubo; };
layout(binding = 9) uniform sampler2D[] textures; 

layout(location = 0) rayPayloadEXT RayPayload ray;

#include "camera.glsl"

void main()
{
	vec3 totalRadiance = vec3(0,0,0);
	vec3 origin;
	vec3 direction;

	uint pixelSeed = tea(tea(gl_LaunchIDEXT.x, gl_LaunchIDEXT.y), ubo.seed);
	ray.seed = pixelSeed;// TODO better sampler

	for(uint s = 0; s < ubo.samplesPerPixel; s++)
	{
		// Calculate camera ray (TODO use specific 2D sampler algorithm to improve results)
		generateCameraRay(pixelSeed, origin, direction);

		ray.pathThroughput = vec3(1,1,1);
		ray.eta = 1;// XXX Must be different if camera inside a medium

		for(uint bounces = 0; bounces < ubo.maxDepth; bounces++)
		{
			// Intersect ray with scene
			const float tMin = 0.001;
			const float tMax = 10000.0;
			traceRayEXT(
				scene, gl_RayFlagsOpaqueEXT, 0xff, 
				0 /*sbtRecordOffset*/, 0 /*sbtRecordStride*/, 0 /*missIndex*/, 
				origin, tMin, direction, tMax, 0 /*payload*/);

			// Add ray contribution
			totalRadiance += ray.radiance;

			// Calculate next ray
			origin = ray.origin;
			direction = ray.wi;

			// Stop if not found intersection
			const bool foundIntersection = ray.t>=0;
			if(!foundIntersection)
				break;
		}
	}

	// Calculate accumulated radiance
	const bool accumulate = ubo.samplesPerPixel != ubo.nAccSamples;
	const vec3 accumulatedRadiance = accumulate ? imageLoad(accumulationImage, ivec2(gl_LaunchIDEXT.xy)).xyz + totalRadiance : totalRadiance;
	imageStore(accumulationImage, ivec2(gl_LaunchIDEXT.xy), vec4(accumulatedRadiance,0));

	// Calculate output radiance
	vec3 outputRadiance = accumulatedRadiance/ubo.nAccSamples;
    imageStore(outputImage, ivec2(gl_LaunchIDEXT.xy), vec4(outputRadiance, 0));
}
