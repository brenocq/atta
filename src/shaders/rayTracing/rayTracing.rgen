//--------------------------------------------------
// Atta Ray Tracing Vulkan GLSL
// rayTracing.rgen
// Date: 2021-02-09
// By Breno Cunha Queiroz
//--------------------------------------------------
#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_tracing : require

#include "samplers/random.glsl"
#include "lights/light.glsl"
#include "rayPayload.glsl"
#include "camera.glsl"
#include "uniformBufferObject.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureEXT scene;
layout(binding = 1, rgba32f) uniform image2D accumulationImage;
layout(binding = 2, rgba8) uniform image2D outputImage;
layout(binding = 3) readonly uniform UniformBufferObjectStruct { UniformBufferObject ubo; };
layout(binding = 8) readonly buffer LightStruct
{ 
	Light[] lights;
};

layout(location = 0) rayPayloadEXT RayPayload ray;

void main() 
{
	vec3 pixelColor = vec3(0);
	uint pixelSeed = tea(tea(gl_LaunchIDEXT.x, gl_LaunchIDEXT.y), ubo.seed);

	// Accumulate all the rays for this pixels
	for(uint s = 0; s < ubo.samplesPerPixel; s++)
	{
		// Sample pixel (TODO use specific 2D sampler algorithm to improve results)
		const vec2 pixel = vec2(gl_LaunchIDEXT.x+randomFloat(pixelSeed)-0.5, gl_LaunchIDEXT.y+randomFloat(pixelSeed)-0.5);
		const vec2 uv = (pixel / gl_LaunchSizeEXT.xy) * 2.0 - 1.0;

		// Calculate camera ray (TODO use specific 2D sampler algorithm to improve results)
		CameraRay rayFromCamera;
		float lensRadius = 0.125;
		float focusDistance = 17.32;
		rayFromCamera = generateRayProjectiveCamera(
			ubo.projMatInverse, ubo.viewMatInverse, uv, 
			lensRadius, focusDistance, vec2(randomFloat(pixelSeed), randomFloat(pixelSeed)));
		vec4 origin = vec4(rayFromCamera.origin, 1);
		vec4 direction = vec4(rayFromCamera.direction, 0);

		// Path integrator
		vec3 L = vec3(0.f);// Radiance value
		vec3 beta = vec3(1.f);// Path throughput weight (BSDF*Geometry) (fraction of radiance from the light source that arrives at the camera)
		bool specularBounce = false;// Handle special case when the ray reflects in only one direction
		uint bounces;

		for(bounces = 0;; bounces++)
		{
			const float tMin = 0.001;
			const float tMax = 10000.0;

			// Intersect ray with scene
			traceRayEXT(
				scene, gl_RayFlagsOpaqueEXT, 0xff, 
				0 /*sbtRecordOffset*/, 0 /*sbtRecordStride*/, 0 /*missIndex*/, 
				origin.xyz, tMin, direction.xyz, tMax, 0 /*payload*/);

			const vec3 hitColor = ray.colorAndDistance.rgb;
			const float t = ray.colorAndDistance.w;
			const bool foundIntersection = (t>=0);

			// Add emitted light
			if(bounces == 0 || specularBounce)
			{
				if(foundIntersection)
				{
					// TODO Add emitted light at path vertex (Emissive objects not supported yet)
					L += beta * vec3(0,0,0);
				}
				else
				{
					// TODO Add environment light (Infinity lights not supported yet)
					// Search infinity lights
					L += beta * vec3(0,0,0);
				}
			}

			// Terminate path if ray miss or maxDepth reached
			if(!foundIntersection || bounces>=ubo.maxDepth)
				break;

			// TODO Uniform sample one light (Ld = beta*qtyLights*estimateDirect)
			// vec3 Ld = beta*uniformSampleOneLight(origin, lights)
			// L += Ld

			// Update next ray origin from intersection
			origin = origin + t * direction;
			// Update next ray direction from BSDF sample
			direction = vec4(ray.scatterDirection.xyz, 0);
			// f = ?
			// pdf = ?
			// specularBounce = ? // Specular brdf -> solve delta distribution (special case)
			// beta *= f * abs(dot())/pdf

			// Possibly terminate the path with Russian roulette
			if(bounces > 3)
			{
				float q = max(0.05, 1-beta.y);
				//if(rand1D < q)
				//	break;
				//beta /= 1-q
			}

			beta *= hitColor;
		}

		pixelColor += beta;
	}

	//const bool accumulate = camera.numberOfSamples != camera.totalNumberOfSamples;
	//const vec3 accumulatedColor = imageLoad(accumulationImage, ivec2(gl_LaunchIDEXT.xy)).xyz + pixelColor;
	//pixelColor = accumulatedColor/ubo.totalNumberOfSamples;
	pixelColor = pixelColor/ubo.samplesPerPixel;

	//if(camera.gammaCorrection)
	//{
	//	// Apply raytracing-in-one-weekend gamma correction.
	//	pixelColor = sqrt(pixelColor);
	//}

	//imageStore(accumulationImage, ivec2(gl_LaunchIDEXT.xy), vec4(accumulatedColor, 0));
    imageStore(outputImage, ivec2(gl_LaunchIDEXT.xy), vec4(pixelColor, 0));
}
